from ast import literal_eval
import itertools
from operator import itemgetter
from pathlib import Path
import re
from typing import Iterable, Literal, Protocol
from isort import file
import numpy as np
from tqdm import tqdm
from libraries.parsend import StageDict, group_stage_basenames
from make_fmi_plots import make_fmi_plots
from trackmetrics import average_area, average_mindistance, minimum_distance
from utils.inquire import inquire
from utils.log_scale import LogScale
from utils.statplots import plot_CI
from utils.associations import get_full_associations
from utils.parse_tracks import QCTracks,TrackAnalysis
from utils.filegetter import afn, adir
import matplotlib.pyplot as plt



qnames = [afn(key="track1",title="Automatic QC Tracks"),afn(key="track2",title="Manual QC Tracks")]

d1 = QCTracks(qnames[0])
d2 = QCTracks(qnames[1])


anames = [afn(key="autotrackanalysis",title="Automatic Track Analysis"),afn(key="mantrackanalysis",title="Manual Track Analysis")]
analyses = [TrackAnalysis(aname) for aname in anames]

nd = afn(key="nd",title="ND Location",filetypes=[(".ND files","*.nd")])

experiment = int(re.match(r".*?(\d+)$",str(Path(anames[0]).parent)).group(1))
# print(experiment)
# from IPython import embed; embed()

smoothing = "smoothed" if "smoothed" in anames[0] else "raw" if "raw" in anames[0] else "noqc" if "noqc" in anames[0] else None
assert smoothing is not None
assert smoothing in anames[0] and smoothing in anames[1]
assoc_path = f"associations/assoc_results_{experiment}_{smoothing}.txt"

associations,inclusions,remainders = get_full_associations(d1,d2,names=("Automatic","Manual"),savepath=assoc_path)



class Metric(Protocol):
    __name__:str
    def __call__(self, trackn:Literal[0,1],selections:list[tuple[int,int]],name:str)->Iterable[float]:...

distances = minimum_distance(d1),minimum_distance(d2)
def mindist(trackn:Literal[0,1],selections:list[tuple[int,int]],name:str)->list[float]:
    return [distances[trackn][s[0]][s[1]] for s in selections]

areas = average_area(d1),average_area(d2)
def avgarea(trackn:Literal[0,1],selections:list[tuple[int,int]],name:str)->list[float]:
    return [areas[trackn][s[0]][s[1]] for s in selections]

# def fmi(trackn:Literal[0,1],selections:list[tuple[int,int]],name:str,axis:Literal['x','y']="y")->list[float]:
#     return [float(analyses[trackn][s[0]][s[1]][f"FMI.{axis}"]) for s in selections]

adistances = average_mindistance(d1),average_mindistance(d2)
def avgdist(trackn:Literal[0,1],selections:list[tuple[int,int]],name:str)->list[float]:
    return [adistances[trackn][s[0]][s[1]] for s in selections]

def analysis_metric(metric:str):
    def func(trackn:Literal[0,1],selections:list[tuple[int,int]],name:str)->list[float]:
        return [float(analyses[trackn][s[0]][s[1]][metric]) for s in selections]
    func.__name__ = metric
    return func

### THIS IS A BAD METRIC WHEN NOT GROUPED!!!
fmiy = analysis_metric("FMI.y")

if "scaled" in qnames[0]:
    length = analysis_metric("Tracklength (microns)")
    duration = analysis_metric("Track time (min)")
    pers = analysis_metric("Persistence")
    speed = analysis_metric("Speed (microns/min)")
    disp = analysis_metric("Displacement Distance (microns)")
else:
    length = analysis_metric("Tracklength (pixels)")
    duration = analysis_metric("Track time (frame)")
    pers = analysis_metric("Persistence")
    speed = analysis_metric("Speed (pixels/frame)")
    disp = analysis_metric("Displacement Distance (pixels)")


idxs:list[Literal[0,1]] = [0,0,0,1,1,1]
groups = [remainders[0],remainders[0]+inclusions[0],inclusions[0],inclusions[1],inclusions[1]+remainders[1],remainders[1]]
names = ["Automatic Remainders","All Automatic","Automatic Paired","Manual Paired","All Manual","Manual Remainders"]


maxwidth = 0.7
width_scale = LogScale((0,maxwidth),(0.0001,1));

def save_all_plots(figures=None):
    savedir = Path(adir(title="Select Save Directory (names will be autogenerated)"))
    if figures is None:
        figures = [plt.figure(f) for f in plt.get_fignums()]
    for f in tqdm(figures):
        f.set_size_inches((11, 10), forward=False)
        n = f.get_label()
        n = n.replace("\\"," per ").replace("/"," per ")
        f.savefig(savedir/f"{n}.png",dpi=500);

do_save = False
while True:

    metrics:list[Metric] = [length,pers,mindist,avgdist,speed,duration,disp,avgarea]
    mnames:list[str] = [metric.__name__ for metric in metrics]
    for name,metric in zip(tqdm(mnames),metrics):
        plt.figure(name)
        plt.title(name)
        lens = [len(g) for g in groups]
        maxlens = {k: max([l[1] for l in v]) for (k,v) in itertools.groupby(sorted(zip(idxs,lens)),key=itemgetter(0))}
        # print(maxlens,lens)
        for idx in tqdm(range(len(groups)),leave=False):
            selection = groups[idx]
            selection = [s for s in selection]
            values = metric(idxs[idx],selection,names[idx])
            maxlen = maxlens[idxs[idx]]
            norm = len(selection)/maxlen
            # print(norm)
            if values:
                plot_CI(idx,values,type="violin",width=width_scale.log_to_linear(norm))
                plot_CI(idx,values)
        plt.ylabel(name)
        plt.xticks(range(len(groups)),[f"{n}\n({l} cells)" for l,n in zip(lens,names)])


    movie_groups = group_stage_basenames(StageDict(nd))
    make_fmi_plots([anames[0],anames[0],anames[1],anames[1]],selects=[groups[1],groups[2],groups[4],groups[3]],names=["Auto total","Auto paired","Manual total","Manual paired"],grouplist=movie_groups)



    if do_save:
        print("replot finished, saving...")
        save_all_plots()
        do_save = False

    figures = [plt.figure(f) for f in plt.get_fignums()]

    from IPython import embed; embed() 
    plt.close('all')

    action = inquire("What do you want to do?",["Replot","Add Filter","Save Plots","Exit"])

    match action:
        case "Add Filter":
            filtername = inquire("What metric would you like to filter by?",["No Filtering"] + mnames)
            if filtername != "No Filtering":
                metric = metrics[mnames.index(filtername)]

                limits = literal_eval(input("Lower limit: ")),literal_eval(input("Upper limit: "))
                
                newgroups = []
                for idx in range(len(groups)):
                    selection = groups[idx]
                    values = metric(idxs[idx],selection,names[idx])
                    good = [s for s,v in zip(selection,values) if (limits[0] is None or v >= limits[0]) and (limits[1] is None or v <= limits[1])]
                    newgroups.append(good)

                groups = newgroups
        case "Exit":
            exit()
        case "Save Plots":
            # print(plt.get_fignums())
            # if len(plt.get_fignums()) == 0:
            #     do_save = True
            #     print("replotting to save")
            #     continue
            # else:
                # print("saving plots immediate")
            save_all_plots(figures)
        case "Replot":
            continue
    

